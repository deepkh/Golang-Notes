// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpcftp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpcftp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpcftp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpcftp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpcftp_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpcftp_2eproto;
namespace protos {
class File;
class FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class FileSegment;
class FileSegmentDefaultTypeInternal;
extern FileSegmentDefaultTypeInternal _FileSegment_default_instance_;
class HelloRequest;
class HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class HelloResponse;
class HelloResponseDefaultTypeInternal;
extern HelloResponseDefaultTypeInternal _HelloResponse_default_instance_;
class ListRequest;
class ListRequestDefaultTypeInternal;
extern ListRequestDefaultTypeInternal _ListRequest_default_instance_;
class ListResponse;
class ListResponseDefaultTypeInternal;
extern ListResponseDefaultTypeInternal _ListResponse_default_instance_;
class PullRequest;
class PullRequestDefaultTypeInternal;
extern PullRequestDefaultTypeInternal _PullRequest_default_instance_;
class PullResponse;
class PullResponseDefaultTypeInternal;
extern PullResponseDefaultTypeInternal _PullResponse_default_instance_;
class PushRequest;
class PushRequestDefaultTypeInternal;
extern PushRequestDefaultTypeInternal _PushRequest_default_instance_;
class PushResponse;
class PushResponseDefaultTypeInternal;
extern PushResponseDefaultTypeInternal _PushResponse_default_instance_;
}  // namespace protos
PROTOBUF_NAMESPACE_OPEN
template<> ::protos::File* Arena::CreateMaybeMessage<::protos::File>(Arena*);
template<> ::protos::FileSegment* Arena::CreateMaybeMessage<::protos::FileSegment>(Arena*);
template<> ::protos::HelloRequest* Arena::CreateMaybeMessage<::protos::HelloRequest>(Arena*);
template<> ::protos::HelloResponse* Arena::CreateMaybeMessage<::protos::HelloResponse>(Arena*);
template<> ::protos::ListRequest* Arena::CreateMaybeMessage<::protos::ListRequest>(Arena*);
template<> ::protos::ListResponse* Arena::CreateMaybeMessage<::protos::ListResponse>(Arena*);
template<> ::protos::PullRequest* Arena::CreateMaybeMessage<::protos::PullRequest>(Arena*);
template<> ::protos::PullResponse* Arena::CreateMaybeMessage<::protos::PullResponse>(Arena*);
template<> ::protos::PushRequest* Arena::CreateMaybeMessage<::protos::PushRequest>(Arena*);
template<> ::protos::PushResponse* Arena::CreateMaybeMessage<::protos::PushResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protos {

enum File_Type : int {
  File_Type_FILE = 0,
  File_Type_DIRECTORY = 1,
  File_Type_File_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  File_Type_File_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool File_Type_IsValid(int value);
constexpr File_Type File_Type_Type_MIN = File_Type_FILE;
constexpr File_Type File_Type_Type_MAX = File_Type_DIRECTORY;
constexpr int File_Type_Type_ARRAYSIZE = File_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* File_Type_descriptor();
template<typename T>
inline const std::string& File_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, File_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function File_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    File_Type_descriptor(), enum_t_value);
}
inline bool File_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, File_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<File_Type>(
    File_Type_descriptor(), name, value);
}
// ===================================================================

class HelloRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const final {
    return CreateMaybeMessage<HelloRequest>(nullptr);
  }

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:protos.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class HelloResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.HelloResponse) */ {
 public:
  inline HelloResponse() : HelloResponse(nullptr) {}
  virtual ~HelloResponse();

  HelloResponse(const HelloResponse& from);
  HelloResponse(HelloResponse&& from) noexcept
    : HelloResponse() {
    *this = ::std::move(from);
  }

  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloResponse& operator=(HelloResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HelloResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloResponse* internal_default_instance() {
    return reinterpret_cast<const HelloResponse*>(
               &_HelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HelloResponse& a, HelloResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloResponse* New() const final {
    return CreateMaybeMessage<HelloResponse>(nullptr);
  }

  HelloResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HelloResponse& from);
  void MergeFrom(const HelloResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.HelloResponse";
  }
  protected:
  explicit HelloResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:protos.HelloResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class ListRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.ListRequest) */ {
 public:
  inline ListRequest() : ListRequest(nullptr) {}
  virtual ~ListRequest();

  ListRequest(const ListRequest& from);
  ListRequest(ListRequest&& from) noexcept
    : ListRequest() {
    *this = ::std::move(from);
  }

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRequest& operator=(ListRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListRequest* internal_default_instance() {
    return reinterpret_cast<const ListRequest*>(
               &_ListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListRequest& a, ListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRequest* New() const final {
    return CreateMaybeMessage<ListRequest>(nullptr);
  }

  ListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListRequest& from);
  void MergeFrom(const ListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.ListRequest";
  }
  protected:
  explicit ListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 1,
  };
  // .protos.File file = 1;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::protos::File& file() const;
  ::protos::File* release_file();
  ::protos::File* mutable_file();
  void set_allocated_file(::protos::File* file);
  private:
  const ::protos::File& _internal_file() const;
  ::protos::File* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::protos::File* file);
  ::protos::File* unsafe_arena_release_file();

  // @@protoc_insertion_point(class_scope:protos.ListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protos::File* file_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class ListResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.ListResponse) */ {
 public:
  inline ListResponse() : ListResponse(nullptr) {}
  virtual ~ListResponse();

  ListResponse(const ListResponse& from);
  ListResponse(ListResponse&& from) noexcept
    : ListResponse() {
    *this = ::std::move(from);
  }

  inline ListResponse& operator=(const ListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResponse& operator=(ListResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListResponse* internal_default_instance() {
    return reinterpret_cast<const ListResponse*>(
               &_ListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListResponse& a, ListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListResponse* New() const final {
    return CreateMaybeMessage<ListResponse>(nullptr);
  }

  ListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListResponse& from);
  void MergeFrom(const ListResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.ListResponse";
  }
  protected:
  explicit ListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 1,
  };
  // .protos.File file = 1;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::protos::File& file() const;
  ::protos::File* release_file();
  ::protos::File* mutable_file();
  void set_allocated_file(::protos::File* file);
  private:
  const ::protos::File& _internal_file() const;
  ::protos::File* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::protos::File* file);
  ::protos::File* unsafe_arena_release_file();

  // @@protoc_insertion_point(class_scope:protos.ListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protos::File* file_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class PullRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PullRequest) */ {
 public:
  inline PullRequest() : PullRequest(nullptr) {}
  virtual ~PullRequest();

  PullRequest(const PullRequest& from);
  PullRequest(PullRequest&& from) noexcept
    : PullRequest() {
    *this = ::std::move(from);
  }

  inline PullRequest& operator=(const PullRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullRequest& operator=(PullRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PullRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullRequest* internal_default_instance() {
    return reinterpret_cast<const PullRequest*>(
               &_PullRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PullRequest& a, PullRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PullRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PullRequest* New() const final {
    return CreateMaybeMessage<PullRequest>(nullptr);
  }

  PullRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PullRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PullRequest& from);
  void MergeFrom(const PullRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.PullRequest";
  }
  protected:
  explicit PullRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 1,
  };
  // .protos.File file = 1;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::protos::File& file() const;
  ::protos::File* release_file();
  ::protos::File* mutable_file();
  void set_allocated_file(::protos::File* file);
  private:
  const ::protos::File& _internal_file() const;
  ::protos::File* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::protos::File* file);
  ::protos::File* unsafe_arena_release_file();

  // @@protoc_insertion_point(class_scope:protos.PullRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protos::File* file_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class PullResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PullResponse) */ {
 public:
  inline PullResponse() : PullResponse(nullptr) {}
  virtual ~PullResponse();

  PullResponse(const PullResponse& from);
  PullResponse(PullResponse&& from) noexcept
    : PullResponse() {
    *this = ::std::move(from);
  }

  inline PullResponse& operator=(const PullResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullResponse& operator=(PullResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PullResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PullResponse* internal_default_instance() {
    return reinterpret_cast<const PullResponse*>(
               &_PullResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PullResponse& a, PullResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PullResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PullResponse* New() const final {
    return CreateMaybeMessage<PullResponse>(nullptr);
  }

  PullResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PullResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PullResponse& from);
  void MergeFrom(const PullResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.PullResponse";
  }
  protected:
  explicit PullResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentFieldNumber = 1,
  };
  // .protos.FileSegment segment = 1;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  const ::protos::FileSegment& segment() const;
  ::protos::FileSegment* release_segment();
  ::protos::FileSegment* mutable_segment();
  void set_allocated_segment(::protos::FileSegment* segment);
  private:
  const ::protos::FileSegment& _internal_segment() const;
  ::protos::FileSegment* _internal_mutable_segment();
  public:
  void unsafe_arena_set_allocated_segment(
      ::protos::FileSegment* segment);
  ::protos::FileSegment* unsafe_arena_release_segment();

  // @@protoc_insertion_point(class_scope:protos.PullResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protos::FileSegment* segment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class PushRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PushRequest) */ {
 public:
  inline PushRequest() : PushRequest(nullptr) {}
  virtual ~PushRequest();

  PushRequest(const PushRequest& from);
  PushRequest(PushRequest&& from) noexcept
    : PushRequest() {
    *this = ::std::move(from);
  }

  inline PushRequest& operator=(const PushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushRequest& operator=(PushRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PushRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushRequest* internal_default_instance() {
    return reinterpret_cast<const PushRequest*>(
               &_PushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PushRequest& a, PushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushRequest* New() const final {
    return CreateMaybeMessage<PushRequest>(nullptr);
  }

  PushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PushRequest& from);
  void MergeFrom(const PushRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.PushRequest";
  }
  protected:
  explicit PushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentFieldNumber = 1,
  };
  // .protos.FileSegment segment = 1;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  const ::protos::FileSegment& segment() const;
  ::protos::FileSegment* release_segment();
  ::protos::FileSegment* mutable_segment();
  void set_allocated_segment(::protos::FileSegment* segment);
  private:
  const ::protos::FileSegment& _internal_segment() const;
  ::protos::FileSegment* _internal_mutable_segment();
  public:
  void unsafe_arena_set_allocated_segment(
      ::protos::FileSegment* segment);
  ::protos::FileSegment* unsafe_arena_release_segment();

  // @@protoc_insertion_point(class_scope:protos.PushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::protos::FileSegment* segment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class PushResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.PushResponse) */ {
 public:
  inline PushResponse() : PushResponse(nullptr) {}
  virtual ~PushResponse();

  PushResponse(const PushResponse& from);
  PushResponse(PushResponse&& from) noexcept
    : PushResponse() {
    *this = ::std::move(from);
  }

  inline PushResponse& operator=(const PushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushResponse& operator=(PushResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PushResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushResponse* internal_default_instance() {
    return reinterpret_cast<const PushResponse*>(
               &_PushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PushResponse& a, PushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushResponse* New() const final {
    return CreateMaybeMessage<PushResponse>(nullptr);
  }

  PushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PushResponse& from);
  void MergeFrom(const PushResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.PushResponse";
  }
  protected:
  explicit PushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int32 status = 1;
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:protos.PushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class FileSegment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.FileSegment) */ {
 public:
  inline FileSegment() : FileSegment(nullptr) {}
  virtual ~FileSegment();

  FileSegment(const FileSegment& from);
  FileSegment(FileSegment&& from) noexcept
    : FileSegment() {
    *this = ::std::move(from);
  }

  inline FileSegment& operator=(const FileSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileSegment& operator=(FileSegment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FileSegment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileSegment* internal_default_instance() {
    return reinterpret_cast<const FileSegment*>(
               &_FileSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FileSegment& a, FileSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(FileSegment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileSegment* New() const final {
    return CreateMaybeMessage<FileSegment>(nullptr);
  }

  FileSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileSegment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileSegment& from);
  void MergeFrom(const FileSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileSegment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.FileSegment";
  }
  protected:
  explicit FileSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kBufFieldNumber = 2,
    kAvailableSizeFieldNumber = 3,
  };
  // string file_name = 1;
  void clear_file_name();
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // bytes buf = 2;
  void clear_buf();
  const std::string& buf() const;
  void set_buf(const std::string& value);
  void set_buf(std::string&& value);
  void set_buf(const char* value);
  void set_buf(const void* value, size_t size);
  std::string* mutable_buf();
  std::string* release_buf();
  void set_allocated_buf(std::string* buf);
  private:
  const std::string& _internal_buf() const;
  void _internal_set_buf(const std::string& value);
  std::string* _internal_mutable_buf();
  public:

  // uint64 available_size = 3;
  void clear_available_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 available_size() const;
  void set_available_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_available_size() const;
  void _internal_set_available_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:protos.FileSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 available_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// -------------------------------------------------------------------

class File PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protos.File) */ {
 public:
  inline File() : File(nullptr) {}
  virtual ~File();

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline File* New() const final {
    return CreateMaybeMessage<File>(nullptr);
  }

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<File>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protos.File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_grpcftp_2eproto);
    return ::descriptor_table_grpcftp_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef File_Type Type;
  static constexpr Type FILE =
    File_Type_FILE;
  static constexpr Type DIRECTORY =
    File_Type_DIRECTORY;
  static inline bool Type_IsValid(int value) {
    return File_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    File_Type_Type_MIN;
  static constexpr Type Type_MAX =
    File_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    File_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return File_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return File_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return File_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kSizeFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // uint64 size = 3;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .protos.File.Type type = 2;
  void clear_type();
  ::protos::File_Type type() const;
  void set_type(::protos::File_Type value);
  private:
  ::protos::File_Type _internal_type() const;
  void _internal_set_type(::protos::File_Type value);
  public:

  // @@protoc_insertion_point(class_scope:protos.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_grpcftp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string message = 1;
inline void HelloRequest::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HelloRequest::message() const {
  // @@protoc_insertion_point(field_get:protos.HelloRequest.message)
  return _internal_message();
}
inline void HelloRequest::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:protos.HelloRequest.message)
}
inline std::string* HelloRequest::mutable_message() {
  // @@protoc_insertion_point(field_mutable:protos.HelloRequest.message)
  return _internal_mutable_message();
}
inline const std::string& HelloRequest::_internal_message() const {
  return message_.Get();
}
inline void HelloRequest::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HelloRequest::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protos.HelloRequest.message)
}
inline void HelloRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protos.HelloRequest.message)
}
inline void HelloRequest::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protos.HelloRequest.message)
}
inline std::string* HelloRequest::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HelloRequest::release_message() {
  // @@protoc_insertion_point(field_release:protos.HelloRequest.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HelloRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protos.HelloRequest.message)
}

// -------------------------------------------------------------------

// HelloResponse

// string message = 1;
inline void HelloResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HelloResponse::message() const {
  // @@protoc_insertion_point(field_get:protos.HelloResponse.message)
  return _internal_message();
}
inline void HelloResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:protos.HelloResponse.message)
}
inline std::string* HelloResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:protos.HelloResponse.message)
  return _internal_mutable_message();
}
inline const std::string& HelloResponse::_internal_message() const {
  return message_.Get();
}
inline void HelloResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HelloResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protos.HelloResponse.message)
}
inline void HelloResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protos.HelloResponse.message)
}
inline void HelloResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protos.HelloResponse.message)
}
inline std::string* HelloResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HelloResponse::release_message() {
  // @@protoc_insertion_point(field_release:protos.HelloResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HelloResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protos.HelloResponse.message)
}

// -------------------------------------------------------------------

// ListRequest

// .protos.File file = 1;
inline bool ListRequest::_internal_has_file() const {
  return this != internal_default_instance() && file_ != nullptr;
}
inline bool ListRequest::has_file() const {
  return _internal_has_file();
}
inline void ListRequest::clear_file() {
  if (GetArena() == nullptr && file_ != nullptr) {
    delete file_;
  }
  file_ = nullptr;
}
inline const ::protos::File& ListRequest::_internal_file() const {
  const ::protos::File* p = file_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protos::File*>(
      &::protos::_File_default_instance_);
}
inline const ::protos::File& ListRequest::file() const {
  // @@protoc_insertion_point(field_get:protos.ListRequest.file)
  return _internal_file();
}
inline void ListRequest::unsafe_arena_set_allocated_file(
    ::protos::File* file) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_);
  }
  file_ = file;
  if (file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ListRequest.file)
}
inline ::protos::File* ListRequest::release_file() {
  
  ::protos::File* temp = file_;
  file_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protos::File* ListRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_release:protos.ListRequest.file)
  
  ::protos::File* temp = file_;
  file_ = nullptr;
  return temp;
}
inline ::protos::File* ListRequest::_internal_mutable_file() {
  
  if (file_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::File>(GetArena());
    file_ = p;
  }
  return file_;
}
inline ::protos::File* ListRequest::mutable_file() {
  // @@protoc_insertion_point(field_mutable:protos.ListRequest.file)
  return _internal_mutable_file();
}
inline void ListRequest::set_allocated_file(::protos::File* file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete file_;
  }
  if (file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(file);
    if (message_arena != submessage_arena) {
      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:protos.ListRequest.file)
}

// -------------------------------------------------------------------

// ListResponse

// .protos.File file = 1;
inline bool ListResponse::_internal_has_file() const {
  return this != internal_default_instance() && file_ != nullptr;
}
inline bool ListResponse::has_file() const {
  return _internal_has_file();
}
inline void ListResponse::clear_file() {
  if (GetArena() == nullptr && file_ != nullptr) {
    delete file_;
  }
  file_ = nullptr;
}
inline const ::protos::File& ListResponse::_internal_file() const {
  const ::protos::File* p = file_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protos::File*>(
      &::protos::_File_default_instance_);
}
inline const ::protos::File& ListResponse::file() const {
  // @@protoc_insertion_point(field_get:protos.ListResponse.file)
  return _internal_file();
}
inline void ListResponse::unsafe_arena_set_allocated_file(
    ::protos::File* file) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_);
  }
  file_ = file;
  if (file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.ListResponse.file)
}
inline ::protos::File* ListResponse::release_file() {
  
  ::protos::File* temp = file_;
  file_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protos::File* ListResponse::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_release:protos.ListResponse.file)
  
  ::protos::File* temp = file_;
  file_ = nullptr;
  return temp;
}
inline ::protos::File* ListResponse::_internal_mutable_file() {
  
  if (file_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::File>(GetArena());
    file_ = p;
  }
  return file_;
}
inline ::protos::File* ListResponse::mutable_file() {
  // @@protoc_insertion_point(field_mutable:protos.ListResponse.file)
  return _internal_mutable_file();
}
inline void ListResponse::set_allocated_file(::protos::File* file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete file_;
  }
  if (file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(file);
    if (message_arena != submessage_arena) {
      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:protos.ListResponse.file)
}

// -------------------------------------------------------------------

// PullRequest

// .protos.File file = 1;
inline bool PullRequest::_internal_has_file() const {
  return this != internal_default_instance() && file_ != nullptr;
}
inline bool PullRequest::has_file() const {
  return _internal_has_file();
}
inline void PullRequest::clear_file() {
  if (GetArena() == nullptr && file_ != nullptr) {
    delete file_;
  }
  file_ = nullptr;
}
inline const ::protos::File& PullRequest::_internal_file() const {
  const ::protos::File* p = file_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protos::File*>(
      &::protos::_File_default_instance_);
}
inline const ::protos::File& PullRequest::file() const {
  // @@protoc_insertion_point(field_get:protos.PullRequest.file)
  return _internal_file();
}
inline void PullRequest::unsafe_arena_set_allocated_file(
    ::protos::File* file) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_);
  }
  file_ = file;
  if (file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PullRequest.file)
}
inline ::protos::File* PullRequest::release_file() {
  
  ::protos::File* temp = file_;
  file_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protos::File* PullRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_release:protos.PullRequest.file)
  
  ::protos::File* temp = file_;
  file_ = nullptr;
  return temp;
}
inline ::protos::File* PullRequest::_internal_mutable_file() {
  
  if (file_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::File>(GetArena());
    file_ = p;
  }
  return file_;
}
inline ::protos::File* PullRequest::mutable_file() {
  // @@protoc_insertion_point(field_mutable:protos.PullRequest.file)
  return _internal_mutable_file();
}
inline void PullRequest::set_allocated_file(::protos::File* file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete file_;
  }
  if (file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(file);
    if (message_arena != submessage_arena) {
      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:protos.PullRequest.file)
}

// -------------------------------------------------------------------

// PullResponse

// .protos.FileSegment segment = 1;
inline bool PullResponse::_internal_has_segment() const {
  return this != internal_default_instance() && segment_ != nullptr;
}
inline bool PullResponse::has_segment() const {
  return _internal_has_segment();
}
inline void PullResponse::clear_segment() {
  if (GetArena() == nullptr && segment_ != nullptr) {
    delete segment_;
  }
  segment_ = nullptr;
}
inline const ::protos::FileSegment& PullResponse::_internal_segment() const {
  const ::protos::FileSegment* p = segment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protos::FileSegment*>(
      &::protos::_FileSegment_default_instance_);
}
inline const ::protos::FileSegment& PullResponse::segment() const {
  // @@protoc_insertion_point(field_get:protos.PullResponse.segment)
  return _internal_segment();
}
inline void PullResponse::unsafe_arena_set_allocated_segment(
    ::protos::FileSegment* segment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(segment_);
  }
  segment_ = segment;
  if (segment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PullResponse.segment)
}
inline ::protos::FileSegment* PullResponse::release_segment() {
  
  ::protos::FileSegment* temp = segment_;
  segment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protos::FileSegment* PullResponse::unsafe_arena_release_segment() {
  // @@protoc_insertion_point(field_release:protos.PullResponse.segment)
  
  ::protos::FileSegment* temp = segment_;
  segment_ = nullptr;
  return temp;
}
inline ::protos::FileSegment* PullResponse::_internal_mutable_segment() {
  
  if (segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::FileSegment>(GetArena());
    segment_ = p;
  }
  return segment_;
}
inline ::protos::FileSegment* PullResponse::mutable_segment() {
  // @@protoc_insertion_point(field_mutable:protos.PullResponse.segment)
  return _internal_mutable_segment();
}
inline void PullResponse::set_allocated_segment(::protos::FileSegment* segment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete segment_;
  }
  if (segment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(segment);
    if (message_arena != submessage_arena) {
      segment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segment, submessage_arena);
    }
    
  } else {
    
  }
  segment_ = segment;
  // @@protoc_insertion_point(field_set_allocated:protos.PullResponse.segment)
}

// -------------------------------------------------------------------

// PushRequest

// .protos.FileSegment segment = 1;
inline bool PushRequest::_internal_has_segment() const {
  return this != internal_default_instance() && segment_ != nullptr;
}
inline bool PushRequest::has_segment() const {
  return _internal_has_segment();
}
inline void PushRequest::clear_segment() {
  if (GetArena() == nullptr && segment_ != nullptr) {
    delete segment_;
  }
  segment_ = nullptr;
}
inline const ::protos::FileSegment& PushRequest::_internal_segment() const {
  const ::protos::FileSegment* p = segment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::protos::FileSegment*>(
      &::protos::_FileSegment_default_instance_);
}
inline const ::protos::FileSegment& PushRequest::segment() const {
  // @@protoc_insertion_point(field_get:protos.PushRequest.segment)
  return _internal_segment();
}
inline void PushRequest::unsafe_arena_set_allocated_segment(
    ::protos::FileSegment* segment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(segment_);
  }
  segment_ = segment;
  if (segment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protos.PushRequest.segment)
}
inline ::protos::FileSegment* PushRequest::release_segment() {
  
  ::protos::FileSegment* temp = segment_;
  segment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::protos::FileSegment* PushRequest::unsafe_arena_release_segment() {
  // @@protoc_insertion_point(field_release:protos.PushRequest.segment)
  
  ::protos::FileSegment* temp = segment_;
  segment_ = nullptr;
  return temp;
}
inline ::protos::FileSegment* PushRequest::_internal_mutable_segment() {
  
  if (segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::protos::FileSegment>(GetArena());
    segment_ = p;
  }
  return segment_;
}
inline ::protos::FileSegment* PushRequest::mutable_segment() {
  // @@protoc_insertion_point(field_mutable:protos.PushRequest.segment)
  return _internal_mutable_segment();
}
inline void PushRequest::set_allocated_segment(::protos::FileSegment* segment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete segment_;
  }
  if (segment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(segment);
    if (message_arena != submessage_arena) {
      segment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segment, submessage_arena);
    }
    
  } else {
    
  }
  segment_ = segment;
  // @@protoc_insertion_point(field_set_allocated:protos.PushRequest.segment)
}

// -------------------------------------------------------------------

// PushResponse

// int32 status = 1;
inline void PushResponse::clear_status() {
  status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushResponse::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushResponse::status() const {
  // @@protoc_insertion_point(field_get:protos.PushResponse.status)
  return _internal_status();
}
inline void PushResponse::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  status_ = value;
}
inline void PushResponse::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:protos.PushResponse.status)
}

// -------------------------------------------------------------------

// FileSegment

// string file_name = 1;
inline void FileSegment::clear_file_name() {
  file_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FileSegment::file_name() const {
  // @@protoc_insertion_point(field_get:protos.FileSegment.file_name)
  return _internal_file_name();
}
inline void FileSegment::set_file_name(const std::string& value) {
  _internal_set_file_name(value);
  // @@protoc_insertion_point(field_set:protos.FileSegment.file_name)
}
inline std::string* FileSegment::mutable_file_name() {
  // @@protoc_insertion_point(field_mutable:protos.FileSegment.file_name)
  return _internal_mutable_file_name();
}
inline const std::string& FileSegment::_internal_file_name() const {
  return file_name_.Get();
}
inline void FileSegment::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileSegment::set_file_name(std::string&& value) {
  
  file_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protos.FileSegment.file_name)
}
inline void FileSegment::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protos.FileSegment.file_name)
}
inline void FileSegment::set_file_name(const char* value,
    size_t size) {
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protos.FileSegment.file_name)
}
inline std::string* FileSegment::_internal_mutable_file_name() {
  
  return file_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileSegment::release_file_name() {
  // @@protoc_insertion_point(field_release:protos.FileSegment.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileSegment::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protos.FileSegment.file_name)
}

// bytes buf = 2;
inline void FileSegment::clear_buf() {
  buf_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FileSegment::buf() const {
  // @@protoc_insertion_point(field_get:protos.FileSegment.buf)
  return _internal_buf();
}
inline void FileSegment::set_buf(const std::string& value) {
  _internal_set_buf(value);
  // @@protoc_insertion_point(field_set:protos.FileSegment.buf)
}
inline std::string* FileSegment::mutable_buf() {
  // @@protoc_insertion_point(field_mutable:protos.FileSegment.buf)
  return _internal_mutable_buf();
}
inline const std::string& FileSegment::_internal_buf() const {
  return buf_.Get();
}
inline void FileSegment::_internal_set_buf(const std::string& value) {
  
  buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FileSegment::set_buf(std::string&& value) {
  
  buf_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protos.FileSegment.buf)
}
inline void FileSegment::set_buf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protos.FileSegment.buf)
}
inline void FileSegment::set_buf(const void* value,
    size_t size) {
  
  buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protos.FileSegment.buf)
}
inline std::string* FileSegment::_internal_mutable_buf() {
  
  return buf_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FileSegment::release_buf() {
  // @@protoc_insertion_point(field_release:protos.FileSegment.buf)
  return buf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FileSegment::set_allocated_buf(std::string* buf) {
  if (buf != nullptr) {
    
  } else {
    
  }
  buf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buf,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protos.FileSegment.buf)
}

// uint64 available_size = 3;
inline void FileSegment::clear_available_size() {
  available_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FileSegment::_internal_available_size() const {
  return available_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FileSegment::available_size() const {
  // @@protoc_insertion_point(field_get:protos.FileSegment.available_size)
  return _internal_available_size();
}
inline void FileSegment::_internal_set_available_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  available_size_ = value;
}
inline void FileSegment::set_available_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_available_size(value);
  // @@protoc_insertion_point(field_set:protos.FileSegment.available_size)
}

// -------------------------------------------------------------------

// File

// string path = 1;
inline void File::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& File::path() const {
  // @@protoc_insertion_point(field_get:protos.File.path)
  return _internal_path();
}
inline void File::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:protos.File.path)
}
inline std::string* File::mutable_path() {
  // @@protoc_insertion_point(field_mutable:protos.File.path)
  return _internal_mutable_path();
}
inline const std::string& File::_internal_path() const {
  return path_.Get();
}
inline void File::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void File::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protos.File.path)
}
inline void File::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protos.File.path)
}
inline void File::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protos.File.path)
}
inline std::string* File::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* File::release_path() {
  // @@protoc_insertion_point(field_release:protos.File.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void File::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protos.File.path)
}

// .protos.File.Type type = 2;
inline void File::clear_type() {
  type_ = 0;
}
inline ::protos::File_Type File::_internal_type() const {
  return static_cast< ::protos::File_Type >(type_);
}
inline ::protos::File_Type File::type() const {
  // @@protoc_insertion_point(field_get:protos.File.type)
  return _internal_type();
}
inline void File::_internal_set_type(::protos::File_Type value) {
  
  type_ = value;
}
inline void File::set_type(::protos::File_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protos.File.type)
}

// uint64 size = 3;
inline void File::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 File::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 File::size() const {
  // @@protoc_insertion_point(field_get:protos.File.size)
  return _internal_size();
}
inline void File::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
}
inline void File::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:protos.File.size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protos::File_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protos::File_Type>() {
  return ::protos::File_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpcftp_2eproto
